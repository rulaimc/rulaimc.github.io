"use strict";(self.webpackChunkwomeng_docs=self.webpackChunkwomeng_docs||[]).push([[777],{8596(e,i,s){s.r(i),s.d(i,{comp:()=>d,data:()=>n});var l=s(641);const a={},d=(0,s(6262).A)(a,[["render",function(e,i){return(0,l.uX)(),(0,l.CE)("div",null,[...i[0]||(i[0]=[(0,l.Fv)('<h1 id="redis-分布式锁" tabindex="-1"><a class="header-anchor" href="#redis-分布式锁"><span>Redis 分布式锁</span></a></h1><p>分布式锁是什么？为什么需要分布式锁？</p><blockquote><p>分布式锁是保证分布式集群环境下多线程并发安全性的一种手段。</p><p>在没有分布式锁之前，锁只能保证单个应用内多线程的并发安全。在如今全民都分布式的情况下，普通的锁能够发挥的作用比较有限了。</p></blockquote><h2 id="分布式锁的特征" tabindex="-1"><a class="header-anchor" href="#分布式锁的特征"><span>分布式锁的特征</span></a></h2><ul><li>高性能</li><li>可重入</li><li>防死锁</li><li>互斥性</li></ul><h2 id="分布式常见应用场景" tabindex="-1"><a class="header-anchor" href="#分布式常见应用场景"><span>分布式常见应用场景</span></a></h2><ul><li>防止缓存击穿</li><li>任务调度</li><li>秒杀减库存防止超卖这种</li><li>保证接口幂等性</li></ul><h2 id="redis几种部署方式" tabindex="-1"><a class="header-anchor" href="#redis几种部署方式"><span>Redis几种部署方式</span></a></h2><ul><li><strong>单机</strong>：部署简单，但是极度害怕单点故障</li><li><strong>哨兵</strong>：一主多从，主从切换，比较稳。但是锁写到Master后，还没同步到Slave呢，Master挂了Slave选举成了Master，但是Slave里没有锁，其他线程再次能上锁了。不安全。</li><li><strong>集群</strong>：制作了slot分片，锁还是只写到master上，跟哨兵模式的问题相同。</li><li><strong>红锁</strong>：它是 Redis 实现分布式锁相对安全可靠的一种手段。红锁的核心思路是：搞几个独立的Master，比如5个，然后挨个加锁，只要超过一半以上（这里是<code>5 / 2 + 1 = 3</code>个）就代表加锁成功，然后释放锁的时候也逐台释放。这样的好处在于一台Master挂了的话，还有其他的，所以不耽误，看起来好像完美解决了上面的问题。但是它极其麻烦，而且对性能的开销也是其他锁的 N 倍，因为需要逐个加锁，需要多次与 Redis 通信。</li></ul><h2 id="redis锁结构" tabindex="-1"><a class="header-anchor" href="#redis锁结构"><span>Redis锁结构</span></a></h2><p>redis锁其实是一个redis的hash结构，里面至少包含有：</p><ul><li>线程id（uuid）</li><li>过期时间</li><li>重入次数</li></ul><p>读写锁的话还有 锁类型（读锁还是写锁），且读锁可以有多个线程id，而且还要为每个线程id维护一个单独的过期时间。续期的时候不仅续期整个锁的过期时间，还要续期每个线程对应的过期时间。</p><h2 id="redis加锁流程" tabindex="-1"><a class="header-anchor" href="#redis加锁流程"><span>Redis加锁流程</span></a></h2><p><strong>非公平锁</strong>：如果资源还没有锁，就上锁，添加过期时间。如果有锁，就判断是否是当前线程持有的锁，如果是就进行锁重入，重入次数加1，锁续期。如果不是当前线程持有的锁，那就是互斥了，就阻塞等待重试嘛。</p><p><strong>公平锁</strong>：用zset和List按照加锁顺序进行排序，当持有锁的线程执行完之后，处在队列第一位的线程就能拿到锁。</p><h2 id="redission" tabindex="-1"><a class="header-anchor" href="#redission"><span>Redission</span></a></h2><img src="/img/8.png"><h3 id="watchdog-看门狗机制" tabindex="-1"><a class="header-anchor" href="#watchdog-看门狗机制"><span>watchDog 看门狗机制</span></a></h3><p>客户端第一次使用无参的lock()方法时，redis会另外启动一个线程检查锁过期时间，当时间超过三分之一的时候就会进行锁续期，续期使用的是lua脚本，保证了续期的原子性，而且这个专门用来续期的线程主要使用的是netty的时间轮容器，只需要一个线程就可以，对服务器性能消耗极小。另外一个需要注意的刚才也说到了，只有使用无参的lock()方法时才会开启看门狗续期，也就是说并不是所有lock方法都会使用看门狗续期，只有没自定义过期时间的才会开启，默认过期时间是30秒。</p>',20)])])}]]),n=JSON.parse('{"path":"/guide/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html","title":"Redis 分布式锁","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"分布式锁的特征","slug":"分布式锁的特征","link":"#分布式锁的特征","children":[]},{"level":2,"title":"分布式常见应用场景","slug":"分布式常见应用场景","link":"#分布式常见应用场景","children":[]},{"level":2,"title":"Redis几种部署方式","slug":"redis几种部署方式","link":"#redis几种部署方式","children":[]},{"level":2,"title":"Redis锁结构","slug":"redis锁结构","link":"#redis锁结构","children":[]},{"level":2,"title":"Redis加锁流程","slug":"redis加锁流程","link":"#redis加锁流程","children":[]},{"level":2,"title":"Redission","slug":"redission","link":"#redission","children":[{"level":3,"title":"watchDog 看门狗机制","slug":"watchdog-看门狗机制","link":"#watchdog-看门狗机制","children":[]}]}],"git":{"updatedTime":1767700977000,"contributors":[{"name":"womeng","username":"womeng","email":"donglongqin@qq.com","commits":1,"url":"https://github.com/womeng"}],"changelog":[{"hash":"b8e7af09363e2aa76ceb6847db16cbf052e12d54","time":1767700977000,"email":"donglongqin@qq.com","author":"womeng","message":"提交文档"}]},"filePathRelative":"guide/Redis分布式锁.md"}')}}]);