"use strict";(self.webpackChunkwomeng_docs=self.webpackChunkwomeng_docs||[]).push([[274],{4866(e,i,a){a.r(i),a.d(i,{comp:()=>s,data:()=>r});var l=a(641);const n={},s=(0,a(6262).A)(n,[["render",function(e,i){return(0,l.uX)(),(0,l.CE)("div",null,[...i[0]||(i[0]=[(0,l.Fv)('<h1 id="redis" tabindex="-1"><a class="header-anchor" href="#redis"><span>Redis</span></a></h1><h2 id="缓存雪崩" tabindex="-1"><a class="header-anchor" href="#缓存雪崩"><span>缓存雪崩</span></a></h2><p>缓存机器发生了意外，全盘宕机，此时每秒有非常多的请求打到数据库，数据库扛不住，就挂了。</p><p>缓存雪崩的事前事中事后的解决方案如下：</p><ul><li>事前：Redis 高可用，主从+哨兵，Redis cluster，避免全盘崩溃。</li><li>事中：本地 ehcache 缓存 + hystrix 限流&amp;降级，避免 MySQL 被打死。</li><li>事后：Redis 持久化，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据。</li></ul><h2 id="缓存穿透" tabindex="-1"><a class="header-anchor" href="#缓存穿透"><span>缓存穿透</span></a></h2><p>故意请求缓存中不可能存在的数据，比如说数据库记录的id是从1开始的，结果我请求过来的ID全都是负数，那缓存中就不可能有啊，直接视缓存如无物，直接打给数据库，这种就很容易把数据库打死了。解决方法也很简单，每次系统中没查到，就写一个空值到缓存中去，这种下次来就直接找缓存了。如果它用的都是不同的负数ID，那设置空值就没有效果了，可以使用布隆过滤器。</p><ul><li>请求数据的 key 不存在于布隆过滤器中，可以确定数据就一定不会存在于数据库中，系统可以立即返回不存在。</li><li>请求数据的 key 存在于布隆过滤器中，则继续再向缓存中查询。</li></ul><h2 id="缓存击穿" tabindex="-1"><a class="header-anchor" href="#缓存击穿"><span>缓存击穿</span></a></h2><p>某个热点key，访问非常频繁，正处于集中式高并发访问的情况，那当这个key在失效的瞬间，大量请求直接打到数据库。</p><ul><li>如果这个数据基本上永远不会变的，可以尝试设置永不过期</li><li>用定时线程主动给它续期</li><li>用锁，给查询数据库的代码上锁，保证只有极少的请求能够直接访问数据库，其它请求稍后 查询缓存就可以了。</li></ul><h2 id="多个redis实例并发竞争" tabindex="-1"><a class="header-anchor" href="#多个redis实例并发竞争"><span>多个Redis实例并发竞争</span></a></h2><p>多个Redis实例同时并发写一个key</p><ul><li>分布式锁</li><li>用CAS乐观锁，在数据库保存一个时间戳字段，每次更新缓存的时候都对比一下数据库的时间戳是不是要比缓存的时间戳要新，如果是就可以写，否则就说明数据库的是旧数据，不能写缓存。</li></ul><h2 id="常用数据类型和使用场景" tabindex="-1"><a class="header-anchor" href="#常用数据类型和使用场景"><span>常用数据类型和使用场景</span></a></h2><p><a href="https://github.com/doocs/advanced-java/blob/main/docs/high-concurrency/redis-data-types.md" target="_blank" rel="noopener noreferrer">github doocs 文档</a></p><h2 id="redis过期策略" tabindex="-1"><a class="header-anchor" href="#redis过期策略"><span>Redis过期策略</span></a></h2><p><a href="https://github.com/doocs/advanced-java/blob/main/docs/high-concurrency/redis-expiration-policies-and-lru.md" target="_blank" rel="noopener noreferrer">Redis 过期策略是：<strong>定期删除+惰性删除</strong>。</a></p><h2 id="持久化" tabindex="-1"><a class="header-anchor" href="#持久化"><span>持久化</span></a></h2><p><a href="https://github.com/doocs/advanced-java/blob/main/docs/high-concurrency/redis-persistence.md" target="_blank" rel="noopener noreferrer">Redis 的持久化有哪几种方式？不同的持久化机制都有什么优缺点？持久化机制具体底层是如何实现的？</a></p><p>Redis的持久化有两种方式，分别是</p><ul><li>RDB：周期性的持久化方式，也就是每隔一段时间就持久化一次。</li><li>AOF：对每条写入命令作为日志，以 <code>append-only</code> 追加的模式写入一个日志文件中，在 Redis 重启的时候，通过<strong>回放</strong> AOF 日志中的写入指令来重新构建整个数据。</li></ul><p>如果同时使用了两种持久化方式，那么在Redis重启的时候，会优先使用AOF来重新构建数据，因为AOF持久化的数据更加完整，一般都是每秒保存一次，也就是说如果最多只会丢失 1 秒钟的数据。</p><p>优缺点：</p><ul><li>RDB适合做冷备份，可以发送到一些远程存储系统上去，以防不测。</li><li>RDB恢复速度快，相对于AOF来说，RDB的恢复速度更快。</li><li>RDB数据丢失较多，它可能要隔很久才备份一次，而AOF是每秒钟保存一次。</li><li>AOF适合做灾难性的紧急恢复。</li><li>两种方式的性能也都不错。</li></ul><h2 id="如何保证缓存和数据库双写一致性" tabindex="-1"><a class="header-anchor" href="#如何保证缓存和数据库双写一致性"><span>如何保证缓存和数据库双写一致性</span></a></h2><p><a href="https://github.com/doocs/advanced-java/blob/main/docs/high-concurrency/redis-consistence.md" target="_blank" rel="noopener noreferrer">你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题</a></p>',27)])])}]]),r=JSON.parse('{"path":"/guide/Redis.html","title":"Redis","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"缓存雪崩","slug":"缓存雪崩","link":"#缓存雪崩","children":[]},{"level":2,"title":"缓存穿透","slug":"缓存穿透","link":"#缓存穿透","children":[]},{"level":2,"title":"缓存击穿","slug":"缓存击穿","link":"#缓存击穿","children":[]},{"level":2,"title":"多个Redis实例并发竞争","slug":"多个redis实例并发竞争","link":"#多个redis实例并发竞争","children":[]},{"level":2,"title":"常用数据类型和使用场景","slug":"常用数据类型和使用场景","link":"#常用数据类型和使用场景","children":[]},{"level":2,"title":"Redis过期策略","slug":"redis过期策略","link":"#redis过期策略","children":[]},{"level":2,"title":"持久化","slug":"持久化","link":"#持久化","children":[]},{"level":2,"title":"如何保证缓存和数据库双写一致性","slug":"如何保证缓存和数据库双写一致性","link":"#如何保证缓存和数据库双写一致性","children":[]}],"git":{"updatedTime":1767700977000,"contributors":[{"name":"womeng","username":"womeng","email":"donglongqin@qq.com","commits":1,"url":"https://github.com/womeng"}],"changelog":[{"hash":"b8e7af09363e2aa76ceb6847db16cbf052e12d54","time":1767700977000,"email":"donglongqin@qq.com","author":"womeng","message":"提交文档"}]},"filePathRelative":"guide/Redis.md"}')}}]);