"use strict";(self.webpackChunkwomeng_docs=self.webpackChunkwomeng_docs||[]).push([[48],{352(t,e,n){n.r(e),n.d(e,{comp:()=>i,data:()=>r});var a=n(641);const d={},i=(0,n(262).A)(d,[["render",function(t,e){return(0,a.uX)(),(0,a.CE)("div",null,[...e[0]||(e[0]=[(0,a.Fv)('<h1 id="spring" tabindex="-1"><a class="header-anchor" href="#spring"><span>Spring</span></a></h1><h2 id="ioc-控制反转" tabindex="-1"><a class="header-anchor" href="#ioc-控制反转"><span>IOC 控制反转</span></a></h2><p>概念：把对 Bean 的控制权交给 Spring 容器。</p><h2 id="循环依赖" tabindex="-1"><a class="header-anchor" href="#循环依赖"><span>循环依赖</span></a></h2><p>Spring Bean 的循环依赖是通过三级缓存解决的。</p><p>假设有A、B、C三个bean，A引用B，B引用C，C引用A，spring就根据依赖关系把它们全都放到三级缓存里面，当创建C想把A注入到C里面的时候，发现A还在创建当中，一级缓存里面没有A，然后就从三级缓存里通过A的工厂获取A实例，把A实例提到二级缓存中，直接就把这个还没初始化的A注入到C当中，这样C就完成初始化了，然后把C提到一级缓存中，然后继续把C注入给B，把B注入回给A，这样就完成了ABC的初始化，这就是spring创建循环依赖的Bean的过程。</p><table><thead><tr><th>级别</th><th>各级缓存的区别</th></tr></thead><tbody><tr><td>一级</td><td>SingletonObjects，存储单例对象，Bean 已经实例化、初始化</td></tr><tr><td>二级</td><td>EarlySingletonObjects，存储 singletonObject，这个 Bean 实例化了，还没有初始化</td></tr><tr><td>三级</td><td>SingletonFactories，存储 singletonFactory</td></tr></tbody></table><h2 id="bean-的作用域" tabindex="-1"><a class="header-anchor" href="#bean-的作用域"><span>Bean 的作用域</span></a></h2><table><thead><tr><th>作用域</th><th>描述</th></tr></thead><tbody><tr><td>singleton</td><td>以单例的形式存在，只有一个<code>bean</code></td></tr><tr><td>prototype</td><td>多实例，每次调用<code>getBean()</code>时会返回一个新的实例</td></tr><tr><td>request</td><td>每次 HTTP 请求都创建一个新的<code>bean</code></td></tr><tr><td>session</td><td>一个<code>session</code>共用一个<code>bean</code>。不同<code>session</code>使用不同的bean</td></tr></tbody></table><h2 id="bean-的生命周期" tabindex="-1"><a class="header-anchor" href="#bean-的生命周期"><span>Bean 的生命周期</span></a></h2><ol><li>创建实例</li><li>属性赋值</li><li>初始化</li><li>bean 正常使用</li><li>容器关闭，bean 销毁</li></ol><h3 id="单实例和多实例的不同" tabindex="-1"><a class="header-anchor" href="#单实例和多实例的不同"><span>单实例和多实例的不同</span></a></h3><ul><li>单实例下 bean 的生命周期：</li></ul><p>容器启动——&gt;初始化方法——&gt;（容器关闭）销毁方法</p><ul><li>多实例下 bean 的生命周期：</li></ul><p>容器启动——&gt;调用 bean ——&gt;初始化方法——&gt;容器关闭（销毁方法不执行）</p><h3 id="bean-属性的注入方式" tabindex="-1"><a class="header-anchor" href="#bean-属性的注入方式"><span>Bean 属性的注入方式</span></a></h3><ul><li>构造方法注入</li><li>setter 方法注入</li></ul><h2 id="部分设计模式" tabindex="-1"><a class="header-anchor" href="#部分设计模式"><span>部分设计模式</span></a></h2><p>创建<code>Bean</code>的时候使用了<code>单例模式</code>、<code>工厂设计模式</code></p><p>AOP 用到<code>代理模式</code>、<code>适配器模式</code>（功能增强和通知）</p><p>Spring 事务管理也是用到了代理模式，因为本质也是 AOP</p><h2 id="spring-事务" tabindex="-1"><a class="header-anchor" href="#spring-事务"><span>Spring 事务</span></a></h2><p>事务是数据库层面的，Spring 只是基于数据库事务进行扩展。Spring 中有两种事务实现方式：<code>申明式</code> 与 <code>编程式</code>，注解 @Transaction 就属于申明式。</p><h3 id="spring-事务隔离级别" tabindex="-1"><a class="header-anchor" href="#spring-事务隔离级别"><span>Spring 事务隔离级别</span></a></h3><table><thead><tr><th>隔离级别</th><th>说明</th></tr></thead><tbody><tr><td>read uncommitted</td><td>未提交读</td></tr><tr><td>read committed</td><td>已提交读、不可重复读</td></tr><tr><td>repeatable read</td><td>可重复读</td></tr><tr><td>serializable</td><td>可串行化</td></tr></tbody></table><p>Mysql 默认的隔离级别是 可重复读</p><p>Oracle 和 SqlServer 都是已提交读</p><p>数据库配置的隔离级别是<code>已提交读</code>而 Spring 配置的隔离级别是<code>可重复读</code>，这个时候以 Spring 配置的为准，如果 Spring 设置的隔离级别数据库不支持那效果就取决于数据库本身。</p><h3 id="transaction" tabindex="-1"><a class="header-anchor" href="#transaction"><span>@Transaction</span></a></h3><p>Spring 会基于这个类生成一个代理对象,会将这个代理对象作为一个 bean 使用这个代理对象的方法。</p><div class="hint-container tip"><p class="hint-container-title">提示</p><p>如果方法上存在 @transaction 注解，那么代理逻辑会先把事务的自动提交设置为<code>false</code>，然后再去执行原本业务逻辑方法，如果没有出现异常那么代理逻辑中就会将事务进行提交，如果执行业务中出现异常则会进行事务回滚。</p></div><p>Spring 默认会对 RuntimeException 和 Error 进行回滚，可以使用 rollback 属性配置。</p><h3 id="事务传播机制" tabindex="-1"><a class="header-anchor" href="#事务传播机制"><span>事务传播机制</span></a></h3><p>在 Spring 事务管理当中，对调用链中的子方法的事务处理策略叫做事务传播行为，也叫事务传播机制。</p><p>事务传播机制基本上就分为这3类：</p><ul><li>优先使用当前事务</li><li>不适用当前事务，开启新的事务</li><li>不使用任何事务</li></ul><table><thead><tr><th>传播方式</th><th>说明</th></tr></thead><tbody><tr><td>Required</td><td>如果当前没有事务，则自己新建一个事务，如果当前存在事务则加入这个事务（默认）</td></tr><tr><td>Supports</td><td>当前存在事务则加入当前事务,如果当前没有事务,就以非事务方式执行</td></tr><tr><td>Mandatory</td><td>当前存在事务则加入当前事务,如果当前没有事务就以非事务方法执行</td></tr><tr><td>never</td><td>不适用事务,如果当前事务存在,则抛出异常</td></tr><tr><td>nested</td><td>如果当前事务存在,则在嵌套事务中执行,否则Required的操作一样(开启一个事务)</td></tr><tr><td>Requires_new</td><td>创建一个新事务,如果当前存在事务,则挂起该事务</td></tr><tr><td>Not_supported</td><td>以非事务方式执行,如果当前存在事务,则挂起当前事务</td></tr></tbody></table><div class="hint-container caution"><p class="hint-container-title">Spring 事务什么时候会失效？</p><p>Spring 事务原理就是<code>AOP</code>进行切面增强，多数情况下原因是这个切面不生效了</p><ul><li>没有被 Spring 管理</li><li>方法不是 public，事务 @Transaction 只能用于 public 方法上</li><li>类内部自身调用，类里面使用<code>this</code>调用本类的方法(<code>this</code>通常省略)，此时这个<code>this</code>对象不是代理类，而是原始类所以不生效 (解决: 将当前调用方法变成代理类)</li><li>异常捕获或者是抛出异常没有被定义，默认为 RuntimeException</li><li>数据库不支持</li></ul></div>',39)])])}]]),r=JSON.parse('{"path":"/guide/Spring.html","title":"Spring","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"IOC 控制反转","slug":"ioc-控制反转","link":"#ioc-控制反转","children":[]},{"level":2,"title":"循环依赖","slug":"循环依赖","link":"#循环依赖","children":[]},{"level":2,"title":"Bean 的作用域","slug":"bean-的作用域","link":"#bean-的作用域","children":[]},{"level":2,"title":"Bean 的生命周期","slug":"bean-的生命周期","link":"#bean-的生命周期","children":[{"level":3,"title":"单实例和多实例的不同","slug":"单实例和多实例的不同","link":"#单实例和多实例的不同","children":[]},{"level":3,"title":"Bean 属性的注入方式","slug":"bean-属性的注入方式","link":"#bean-属性的注入方式","children":[]}]},{"level":2,"title":"部分设计模式","slug":"部分设计模式","link":"#部分设计模式","children":[]},{"level":2,"title":"Spring 事务","slug":"spring-事务","link":"#spring-事务","children":[{"level":3,"title":"Spring 事务隔离级别","slug":"spring-事务隔离级别","link":"#spring-事务隔离级别","children":[]},{"level":3,"title":"@Transaction","slug":"transaction","link":"#transaction","children":[]},{"level":3,"title":"事务传播机制","slug":"事务传播机制","link":"#事务传播机制","children":[]}]}],"git":{"updatedTime":1767870971000,"contributors":[{"name":"womeng","username":"womeng","email":"donglongqin@qq.com","commits":2,"url":"https://github.com/womeng"}],"changelog":[{"hash":"91c3f57d68f256f69bdf6952d44fd2bc66620f81","time":1767870971000,"email":"donglongqin@qq.com","author":"womeng","message":"Spring"},{"hash":"b8e7af09363e2aa76ceb6847db16cbf052e12d54","time":1767700977000,"email":"donglongqin@qq.com","author":"womeng","message":"提交文档"}]},"filePathRelative":"guide/Spring.md"}')}}]);