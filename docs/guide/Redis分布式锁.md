# Redis 分布式锁

分布式锁是什么？为什么需要分布式锁？

> 分布式锁是保证分布式集群环境下多线程并发安全性的一种手段。
>
> 在没有分布式锁之前，锁只能保证单个应用内多线程的并发安全。在如今全民都分布式的情况下，普通的锁能够发挥的作用比较有限了。

## 分布式锁的特征

- 高性能
- 可重入
- 防死锁
- 互斥性

## 分布式常见应用场景

- 防止缓存击穿
- 任务调度
- 秒杀减库存防止超卖这种
- 保证接口幂等性

## Redis几种部署方式

- **单机**：部署简单，但是极度害怕单点故障
- **哨兵**：一主多从，主从切换，比较稳。但是锁写到Master后，还没同步到Slave呢，Master挂了Slave选举成了Master，但是Slave里没有锁，其他线程再次能上锁了。不安全。
- **集群**：制作了slot分片，锁还是只写到master上，跟哨兵模式的问题相同。
- **红锁**：它是 Redis 实现分布式锁相对安全可靠的一种手段。红锁的核心思路是：搞几个独立的Master，比如5个，然后挨个加锁，只要超过一半以上（这里是`5 / 2 + 1 = 3`个）就代表加锁成功，然后释放锁的时候也逐台释放。这样的好处在于一台Master挂了的话，还有其他的，所以不耽误，看起来好像完美解决了上面的问题。但是它极其麻烦，而且对性能的开销也是其他锁的 N 倍，因为需要逐个加锁，需要多次与 Redis 通信。

## Redis锁结构

redis锁其实是一个redis的hash结构，里面至少包含有：

- 线程id（uuid）
- 过期时间
- 重入次数

读写锁的话还有 锁类型（读锁还是写锁），且读锁可以有多个线程id，而且还要为每个线程id维护一个单独的过期时间。续期的时候不仅续期整个锁的过期时间，还要续期每个线程对应的过期时间。

## Redis加锁流程

**非公平锁**：如果资源还没有锁，就上锁，添加过期时间。如果有锁，就判断是否是当前线程持有的锁，如果是就进行锁重入，重入次数加1，锁续期。如果不是当前线程持有的锁，那就是互斥了，就阻塞等待重试嘛。

**公平锁**：用zset和List按照加锁顺序进行排序，当持有锁的线程执行完之后，处在队列第一位的线程就能拿到锁。

##  Redission

<img src="/img/8.png">

### watchDog 看门狗机制

客户端第一次使用无参的lock()方法时，redis会另外启动一个线程检查锁过期时间，当时间超过三分之一的时候就会进行锁续期，续期使用的是lua脚本，保证了续期的原子性，而且这个专门用来续期的线程主要使用的是netty的时间轮容器，只需要一个线程就可以，对服务器性能消耗极小。另外一个需要注意的刚才也说到了，只有使用无参的lock()方法时才会开启看门狗续期，也就是说并不是所有lock方法都会使用看门狗续期，只有没自定义过期时间的才会开启，默认过期时间是30秒。

